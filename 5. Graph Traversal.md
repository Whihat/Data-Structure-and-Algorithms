# 5.1 Flavours of Graph
- Graph: A graph **G(V, E)** is defined on a _set_ of vertices(point) V, and contains a _set_ of edges E of ordered or unordered pairs vertices from V.
#### Undirected vs. Directed
- A graph G = (V, E) is **undirected** if edge （x, y) ∈ E => (y, x) also ∈ E
- if not, **directed**
![undirected vs. directed](https://github.com/Whihat/Data-Structure-and-Algorithms/blob/master/screenshot/screenshot4.jpg)
#### Weighted vs. Unweighted
- Each edge(or vertex) in a **weighted** graph G  is assigned a numerical value.
- if not assigned, **Unweighted** <br />
![Weighted vs. Unweighted](https://github.com/Whihat/Data-Structure-and-Algorithms/blob/master/screenshot/screenshot5.jpg)
#### Simple vs. Non-Simple
- A self-loop is an edge (x, x) involving only one vertex. An edge (x, y) is a multi-edge if it occurs more than once in the graph is called **Non-simple**
- Any graph that avoids them is called **Simple** <br />
![Simple vs. Non-Simple](https://github.com/Whihat/Data-Structure-and-Algorithms/blob/master/screenshot/screenshot6.jpg)
#### cyclic vs. Acyclic
- An **acyclic** graph does not contain any cycles. Trees are connected, acyclic(_non-periodic_) undirected graphs. i.e. Trees
- Directed acyclic graphs are called **DAGs**, they arise in scheduling problems where a directed edge(x, y) indicates that activity x must occur before y.
- _Topological sorting_ orders the vertices of a DAG to respect these precedence(priority) constraints. Topological sorting is the first step to do DAGs algorithm. <br />
!(cyclic vs. Acyclic)[https://github.com/Whihat/Data-Structure-and-Algorithms/blob/master/screenshot/screenshot7.jpg]

## 5.1.1 The Friendship Graph
- _If I am your friend, does that mean you are my friend?_
   - directed or undirected graph
- _How close a friend are you?_
  - weighted graph
- _Am I my own friend?_
  - simple graph
- _Who has the most friends?_
  - the degree of a vertex is the number of edges adjacent to it
- _Do my friends live near me?_
  - embedded(enclosed) graph
- _Oh, you also know her?_
  - premise of explicitly(correct rate) link.
- _Are you truly an individual, or just one of the faceless crowd?_
  - label or unlabelled

**Take-Home-Lesson**: Graphs can be used to model a wide variety of structures and relationships. Graph-theoretic terminology gives us a language to talk about them.


#5.2 Data structure for graphs
Basically two choices:
  1). Adjacency Matrix.
  2). Adjacency Lists.

1. Adjacency Matrix
- We can represent G using an n × n matrix M, where element M[i, j] = 1 if (i, j) is an edge of G, and 0 if it isn’t. This allows fast answers to the question “is (i, j) in G?”
- However if number of vertices are large, adjacency matrix would be very large.

2. Adjacency Lists
- Using _linked list_ to store the neighbours adjacent to each vertex. Adjacency list require pointers
- Adjacency lists are the right data structure for most applications of Graphs <br />

![Adjacency matrix vs.adjacency list ](https://github.com/Whihat/Data-Structure-and-Algorithms/blob/master/screenshot/screenshot8.jpg)

#### Structure Build
```
  #define MAXV 1000        /* maximum number of vertices */

  typedef struct {
    int y;                 /* adjacency info */
    int weight;            /* edge weight, if any */
    struct edgenode *next; /* next edge in list */
  }edgenode;

  typedef struct {
    edgenode *edges[MAXV+1]; /* adjacency info */
    int degree[MAXV+1];      /* out-degree of each vertex */
    int nvertices;           /* number of vertices in graph */
    int nedges;              /* number of edges in graph */
    bool directed;           /* is the graph directed? */
  }graph;
```
We represent directed edge (x, y) by an edgenode y in x's adjacency list <br />
An undirected edge (x, y) appears twice in any adjacency-based graph structure, once as x in y, once as y in x.

####Read a graph from file
```
  initialise_graph(graph *g, bool directed){
    int i;            /* counter */

    g -> nvertices = 0;
    g -> nedges = 0;
    g -> directed = directed;

    for (i=1; i<=MAXV; i++) g->degree[i] = 0;
    for )i=1; i<=MAXV; i++) g->edges[i] = NULL;
  }

  read_graph(graph *g, bool directed){
    int i;          /* counter */
    int m;          /* number of edges */
    int x,y;        /* vertices in edge(x, y) */

    initialise_graph(g, directed);

    scanf("%d %d,&(g->nvertices), &m");

    for(i=1; i<=m, i++){
      scanf("%d %d",&x,&y);
      insert_edge(x, y, directed);
    }
  }
```
